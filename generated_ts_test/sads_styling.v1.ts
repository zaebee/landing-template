// @generated by protobuf-ts 2.11.1 with parameter generate_dependencies,client_none,server_none,long_type_string
// @generated from protobuf file "sads_styling.v1.proto" (package "sads.v1", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * Represents a single SADS attribute value.
 * This structure allows a SADS attribute to be a predefined token from an enum
 * or a custom string value.
 *
 * @generated from protobuf message sads.v1.SadsAttributeValue
 */
export interface SadsAttributeValue {
  /**
   * @generated from protobuf oneof: value_type
   */
  valueType:
    | {
        oneofKind: "spacingToken";
        /**
         * @generated from protobuf field: sads.v1.SadsSpacingToken spacing_token = 1
         */
        spacingToken: SadsSpacingToken;
      }
    | {
        oneofKind: "colorToken";
        /**
         * @generated from protobuf field: sads.v1.SadsColorToken color_token = 2
         */
        colorToken: SadsColorToken;
      }
    | {
        oneofKind: "fontWeightToken";
        /**
         * @generated from protobuf field: sads.v1.SadsFontWeightToken font_weight_token = 3
         */
        fontWeightToken: SadsFontWeightToken;
      }
    | {
        oneofKind: "borderRadiusToken";
        /**
         * @generated from protobuf field: sads.v1.SadsBorderRadiusToken border_radius_token = 4
         */
        borderRadiusToken: SadsBorderRadiusToken;
      }
    | {
        oneofKind: "fontSizeValue";
        /**
         * @generated from protobuf field: string font_size_value = 5
         */
        fontSizeValue: string; // For font sizes like "1rem", "1.2em", or theme keys like "l".
      }
    | {
        oneofKind: "customValue";
        /**
         * Not an enum as font sizes can be very granular or specific theme
         * keys.
         *
         * @generated from protobuf field: string custom_value = 6
         */
        customValue: string; // For any other CSS value (e.g., "center" for text-align,
      }
    | {
        oneofKind: undefined;
      };
}
/**
 * A collection of SADS attributes for an element.
 * The keys in the map would be SADS property keys as used in data-sads-*
 * attributes (e.g., "bgColor", "padding", "fontSize", "borderRadius",
 * "fontWeight", "textAlign", "display"). The SADS engine (JS/TS or Go/WASM)
 * would then map these SADS property keys to actual CSS properties.
 *
 * @generated from protobuf message sads.v1.SadsStylingSet
 */
export interface SadsStylingSet {
  /**
   * @generated from protobuf field: map<string, sads.v1.SadsAttributeValue> attributes = 1
   */
  attributes: {
    [key: string]: SadsAttributeValue;
  };
}
/**
 * Defines styles for a specific breakpoint.
 *
 * @generated from protobuf message sads.v1.SadsResponsiveStyle
 */
export interface SadsResponsiveStyle {
  /**
   * @generated from protobuf field: string breakpoint_key = 1
   */
  breakpointKey: string; // e.g., "mobile", "tablet". This key maps to a media query
  /**
   * defined in the SADS theme's breakpoints section.
   * Could also be a raw media query string if not using theme keys.
   *
   * @generated from protobuf field: sads.v1.SadsStylingSet styles = 2
   */
  styles?: SadsStylingSet; // The SADS attributes to apply at this breakpoint.
}
/**
 * Represents the complete SADS styling configuration for a single HTML element.
 * This includes its base styles and any responsive overrides.
 *
 * @generated from protobuf message sads.v1.SadsElementStyles
 */
export interface SadsElementStyles {
  /**
   * @generated from protobuf field: optional sads.v1.SadsStylingSet base_styles = 1
   */
  baseStyles?: SadsStylingSet; // Styles applied by default.
  /**
   * @generated from protobuf field: repeated sads.v1.SadsResponsiveStyle responsive_styles = 2
   */
  responsiveStyles: SadsResponsiveStyle[]; // Styles applied at specific breakpoints.
}
/**
 * Contextual information needed by the SADS engine when processing styles for
 * an element.
 *
 * @generated from protobuf message sads.v1.SadsProcessingContext
 */
export interface SadsProcessingContext {
  /**
   * @generated from protobuf field: bool is_dark_mode = 1
   */
  isDarkMode: boolean; // Potentially add language, viewport dimensions, etc., if needed for more
  // advanced styling logic.
}
/**
 * Request to resolve a SadsElementStyles configuration into a CSS string or
 * structured CSS rules. This could be an input to a Go/WASM function.
 *
 * @generated from protobuf message sads.v1.ResolveSadsStylesRequest
 */
export interface ResolveSadsStylesRequest {
  /**
   * @generated from protobuf field: sads.v1.SadsElementStyles element_styles = 1
   */
  elementStyles?: SadsElementStyles; // The styles to resolve.
  /**
   * @generated from protobuf field: sads.v1.SadsProcessingContext context = 2
   */
  context?: SadsProcessingContext; // Context like dark mode.
  /**
   * The SADS Theme itself would also be needed. How to pass it?
   * Option 1: Pass the full theme as a JSON string here.
   * Option 2: Assume WASM module is initialized with a theme or can fetch parts
   * of it. For now, let's assume theme parts are passed as needed, similar to
   * current Go functions. If we move to binary proto for calls, the theme could
   * also be a proto message.
   *
   * @generated from protobuf field: string theme_colors_json = 3
   */
  themeColorsJson: string; // Example: JSON string of theme.colors
  /**
   * @generated from protobuf field: string theme_spacing_json = 4
   */
  themeSpacingJson: string; // Example: JSON string of theme.spacing
  /**
   * @generated from protobuf field: string theme_font_size_json = 5
   */
  themeFontSizeJson: string; // ... and so on for other theme parts
  /**
   * @generated from protobuf field: string theme_breakpoints_json = 6
   */
  themeBreakpointsJson: string; // JSON string of theme.breakpoints
}
/**
 * Response from resolving SADS styles.
 * Could be a simple string if generating full CSS, or more structured.
 *
 * @generated from protobuf message sads.v1.ResolveSadsStylesResponse
 */
export interface ResolveSadsStylesResponse {
  /**
   * @generated from protobuf field: string css_rules = 1
   */
  cssRules: string; // Generated CSS rules as a string.
}
/**
 * Enum for common spacing tokens
 *
 * @generated from protobuf enum sads.v1.SadsSpacingToken
 */
export enum SadsSpacingToken {
  /**
   * Default, should not be used directly for styling
   *
   * @generated from protobuf enum value: SPACING_TOKEN_UNSPECIFIED = 0;
   */
  SPACING_TOKEN_UNSPECIFIED = 0,
  /**
   * "0"
   *
   * @generated from protobuf enum value: SPACING_TOKEN_NONE = 1;
   */
  SPACING_TOKEN_NONE = 1,
  /**
   * e.g., "0.25rem"
   *
   * @generated from protobuf enum value: SPACING_TOKEN_XS = 2;
   */
  SPACING_TOKEN_XS = 2,
  /**
   * e.g., "0.5rem"
   *
   * @generated from protobuf enum value: SPACING_TOKEN_S = 3;
   */
  SPACING_TOKEN_S = 3,
  /**
   * e.g., "1rem"
   *
   * @generated from protobuf enum value: SPACING_TOKEN_M = 4;
   */
  SPACING_TOKEN_M = 4,
  /**
   * e.g., "1.5rem"
   *
   * @generated from protobuf enum value: SPACING_TOKEN_L = 5;
   */
  SPACING_TOKEN_L = 5,
  /**
   * e.g., "2rem"
   *
   * @generated from protobuf enum value: SPACING_TOKEN_XL = 6;
   */
  SPACING_TOKEN_XL = 6,
  /**
   * e.g., "4rem"
   *
   * @generated from protobuf enum value: SPACING_TOKEN_XXL = 7;
   */
  SPACING_TOKEN_XXL = 7,
  /**
   * "auto"
   *
   * @generated from protobuf enum value: SPACING_TOKEN_AUTO = 8;
   */
  SPACING_TOKEN_AUTO = 8,
}
/**
 * Enum for common color semantic tokens
 * These would map to keys in the theme's color palette.
 *
 * @generated from protobuf enum sads.v1.SadsColorToken
 */
export enum SadsColorToken {
  /**
   * @generated from protobuf enum value: COLOR_TOKEN_UNSPECIFIED = 0;
   */
  COLOR_TOKEN_UNSPECIFIED = 0,
  /**
   * "transparent"
   *
   * @generated from protobuf enum value: COLOR_TOKEN_TRANSPARENT = 1;
   */
  COLOR_TOKEN_TRANSPARENT = 1,
  /**
   * @generated from protobuf enum value: COLOR_TOKEN_SURFACE = 2;
   */
  COLOR_TOKEN_SURFACE = 2,
  /**
   * For dark mode variant of SURFACE
   *
   * @generated from protobuf enum value: COLOR_TOKEN_SURFACE_DARK = 3;
   */
  COLOR_TOKEN_SURFACE_DARK = 3,
  /**
   * @generated from protobuf enum value: COLOR_TOKEN_SURFACE_ACCENT = 4;
   */
  COLOR_TOKEN_SURFACE_ACCENT = 4,
  /**
   * For dark mode variant of SURFACE_ACCENT
   *
   * @generated from protobuf enum value: COLOR_TOKEN_SURFACE_ACCENT_DARK = 5;
   */
  COLOR_TOKEN_SURFACE_ACCENT_DARK = 5,
  /**
   * @generated from protobuf enum value: COLOR_TOKEN_TEXT_PRIMARY = 6;
   */
  COLOR_TOKEN_TEXT_PRIMARY = 6,
  /**
   * For dark mode variant of TEXT_PRIMARY
   *
   * @generated from protobuf enum value: COLOR_TOKEN_TEXT_PRIMARY_DARK = 7;
   */
  COLOR_TOKEN_TEXT_PRIMARY_DARK = 7,
  /**
   * @generated from protobuf enum value: COLOR_TOKEN_TEXT_ACCENT = 8;
   */
  COLOR_TOKEN_TEXT_ACCENT = 8,
  /**
   * For dark mode variant of TEXT_ACCENT
   *
   * @generated from protobuf enum value: COLOR_TOKEN_TEXT_ACCENT_DARK = 9;
   */
  COLOR_TOKEN_TEXT_ACCENT_DARK = 9,
  /**
   * Example, could be derived or a direct theme key
   *
   * @generated from protobuf enum value: COLOR_TOKEN_BORDER_ACCENT = 10;
   */
  COLOR_TOKEN_BORDER_ACCENT = 10,
}
/**
 * Enum for font weight tokens
 *
 * @generated from protobuf enum sads.v1.SadsFontWeightToken
 */
export enum SadsFontWeightToken {
  /**
   * @generated from protobuf enum value: FONT_WEIGHT_TOKEN_UNSPECIFIED = 0;
   */
  FONT_WEIGHT_TOKEN_UNSPECIFIED = 0,
  /**
   * e.g., "400"
   *
   * @generated from protobuf enum value: FONT_WEIGHT_TOKEN_NORMAL = 1;
   */
  FONT_WEIGHT_TOKEN_NORMAL = 1,
  /**
   * e.g., "700"
   *
   * @generated from protobuf enum value: FONT_WEIGHT_TOKEN_BOLD = 2;
   */
  FONT_WEIGHT_TOKEN_BOLD = 2,
}
/**
 * Enum for border radius tokens
 *
 * @generated from protobuf enum sads.v1.SadsBorderRadiusToken
 */
export enum SadsBorderRadiusToken {
  /**
   * @generated from protobuf enum value: BORDER_RADIUS_TOKEN_UNSPECIFIED = 0;
   */
  BORDER_RADIUS_TOKEN_UNSPECIFIED = 0,
  /**
   * "0"
   *
   * @generated from protobuf enum value: BORDER_RADIUS_TOKEN_NONE = 1;
   */
  BORDER_RADIUS_TOKEN_NONE = 1,
  /**
   * e.g., "4px"
   *
   * @generated from protobuf enum value: BORDER_RADIUS_TOKEN_S = 2;
   */
  BORDER_RADIUS_TOKEN_S = 2,
  /**
   * e.g., "8px"
   *
   * @generated from protobuf enum value: BORDER_RADIUS_TOKEN_M = 3;
   */
  BORDER_RADIUS_TOKEN_M = 3,
  /**
   * e.g., "16px"
   *
   * @generated from protobuf enum value: BORDER_RADIUS_TOKEN_L = 4;
   */
  BORDER_RADIUS_TOKEN_L = 4,
}
// @generated message type with reflection information, may provide speed optimized methods
class SadsAttributeValue$Type extends MessageType<SadsAttributeValue> {
  constructor() {
    super("sads.v1.SadsAttributeValue", [
      {
        no: 1,
        name: "spacing_token",
        kind: "enum",
        oneof: "valueType",
        T: () => ["sads.v1.SadsSpacingToken", SadsSpacingToken],
      },
      {
        no: 2,
        name: "color_token",
        kind: "enum",
        oneof: "valueType",
        T: () => ["sads.v1.SadsColorToken", SadsColorToken],
      },
      {
        no: 3,
        name: "font_weight_token",
        kind: "enum",
        oneof: "valueType",
        T: () => ["sads.v1.SadsFontWeightToken", SadsFontWeightToken],
      },
      {
        no: 4,
        name: "border_radius_token",
        kind: "enum",
        oneof: "valueType",
        T: () => ["sads.v1.SadsBorderRadiusToken", SadsBorderRadiusToken],
      },
      {
        no: 5,
        name: "font_size_value",
        kind: "scalar",
        oneof: "valueType",
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 6,
        name: "custom_value",
        kind: "scalar",
        oneof: "valueType",
        T: 9 /*ScalarType.STRING*/,
      },
    ]);
  }
  create(value?: PartialMessage<SadsAttributeValue>): SadsAttributeValue {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.valueType = { oneofKind: undefined };
    if (value !== undefined)
      reflectionMergePartial<SadsAttributeValue>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SadsAttributeValue
  ): SadsAttributeValue {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* sads.v1.SadsSpacingToken spacing_token */ 1:
          message.valueType = {
            oneofKind: "spacingToken",
            spacingToken: reader.int32(),
          };
          break;
        case /* sads.v1.SadsColorToken color_token */ 2:
          message.valueType = {
            oneofKind: "colorToken",
            colorToken: reader.int32(),
          };
          break;
        case /* sads.v1.SadsFontWeightToken font_weight_token */ 3:
          message.valueType = {
            oneofKind: "fontWeightToken",
            fontWeightToken: reader.int32(),
          };
          break;
        case /* sads.v1.SadsBorderRadiusToken border_radius_token */ 4:
          message.valueType = {
            oneofKind: "borderRadiusToken",
            borderRadiusToken: reader.int32(),
          };
          break;
        case /* string font_size_value */ 5:
          message.valueType = {
            oneofKind: "fontSizeValue",
            fontSizeValue: reader.string(),
          };
          break;
        case /* string custom_value */ 6:
          message.valueType = {
            oneofKind: "customValue",
            customValue: reader.string(),
          };
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: SadsAttributeValue,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* sads.v1.SadsSpacingToken spacing_token = 1; */
    if (message.valueType.oneofKind === "spacingToken")
      writer.tag(1, WireType.Varint).int32(message.valueType.spacingToken);
    /* sads.v1.SadsColorToken color_token = 2; */
    if (message.valueType.oneofKind === "colorToken")
      writer.tag(2, WireType.Varint).int32(message.valueType.colorToken);
    /* sads.v1.SadsFontWeightToken font_weight_token = 3; */
    if (message.valueType.oneofKind === "fontWeightToken")
      writer.tag(3, WireType.Varint).int32(message.valueType.fontWeightToken);
    /* sads.v1.SadsBorderRadiusToken border_radius_token = 4; */
    if (message.valueType.oneofKind === "borderRadiusToken")
      writer.tag(4, WireType.Varint).int32(message.valueType.borderRadiusToken);
    /* string font_size_value = 5; */
    if (message.valueType.oneofKind === "fontSizeValue")
      writer
        .tag(5, WireType.LengthDelimited)
        .string(message.valueType.fontSizeValue);
    /* string custom_value = 6; */
    if (message.valueType.oneofKind === "customValue")
      writer
        .tag(6, WireType.LengthDelimited)
        .string(message.valueType.customValue);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message sads.v1.SadsAttributeValue
 */
export const SadsAttributeValue = new SadsAttributeValue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SadsStylingSet$Type extends MessageType<SadsStylingSet> {
  constructor() {
    super("sads.v1.SadsStylingSet", [
      {
        no: 1,
        name: "attributes",
        kind: "map",
        K: 9 /*ScalarType.STRING*/,
        V: { kind: "message", T: () => SadsAttributeValue },
      },
    ]);
  }
  create(value?: PartialMessage<SadsStylingSet>): SadsStylingSet {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.attributes = {};
    if (value !== undefined)
      reflectionMergePartial<SadsStylingSet>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SadsStylingSet
  ): SadsStylingSet {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* map<string, sads.v1.SadsAttributeValue> attributes */ 1:
          this.binaryReadMap1(message.attributes, reader, options);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  private binaryReadMap1(
    map: SadsStylingSet["attributes"],
    reader: IBinaryReader,
    options: BinaryReadOptions
  ): void {
    let len = reader.uint32(),
      end = reader.pos + len,
      key: keyof SadsStylingSet["attributes"] | undefined,
      val: SadsStylingSet["attributes"][any] | undefined;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case 1:
          key = reader.string();
          break;
        case 2:
          val = SadsAttributeValue.internalBinaryRead(
            reader,
            reader.uint32(),
            options
          );
          break;
        default:
          throw new globalThis.Error(
            "unknown map entry field for sads.v1.SadsStylingSet.attributes"
          );
      }
    }
    map[key ?? ""] = val ?? SadsAttributeValue.create();
  }
  internalBinaryWrite(
    message: SadsStylingSet,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* map<string, sads.v1.SadsAttributeValue> attributes = 1; */
    for (let k of globalThis.Object.keys(message.attributes)) {
      writer
        .tag(1, WireType.LengthDelimited)
        .fork()
        .tag(1, WireType.LengthDelimited)
        .string(k);
      writer.tag(2, WireType.LengthDelimited).fork();
      SadsAttributeValue.internalBinaryWrite(
        message.attributes[k],
        writer,
        options
      );
      writer.join().join();
    }
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message sads.v1.SadsStylingSet
 */
export const SadsStylingSet = new SadsStylingSet$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SadsResponsiveStyle$Type extends MessageType<SadsResponsiveStyle> {
  constructor() {
    super("sads.v1.SadsResponsiveStyle", [
      {
        no: 1,
        name: "breakpoint_key",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      { no: 2, name: "styles", kind: "message", T: () => SadsStylingSet },
    ]);
  }
  create(value?: PartialMessage<SadsResponsiveStyle>): SadsResponsiveStyle {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.breakpointKey = "";
    if (value !== undefined)
      reflectionMergePartial<SadsResponsiveStyle>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SadsResponsiveStyle
  ): SadsResponsiveStyle {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string breakpoint_key */ 1:
          message.breakpointKey = reader.string();
          break;
        case /* sads.v1.SadsStylingSet styles */ 2:
          message.styles = SadsStylingSet.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.styles
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: SadsResponsiveStyle,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string breakpoint_key = 1; */
    if (message.breakpointKey !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.breakpointKey);
    /* sads.v1.SadsStylingSet styles = 2; */
    if (message.styles)
      SadsStylingSet.internalBinaryWrite(
        message.styles,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message sads.v1.SadsResponsiveStyle
 */
export const SadsResponsiveStyle = new SadsResponsiveStyle$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SadsElementStyles$Type extends MessageType<SadsElementStyles> {
  constructor() {
    super("sads.v1.SadsElementStyles", [
      { no: 1, name: "base_styles", kind: "message", T: () => SadsStylingSet },
      {
        no: 2,
        name: "responsive_styles",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => SadsResponsiveStyle,
      },
    ]);
  }
  create(value?: PartialMessage<SadsElementStyles>): SadsElementStyles {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.responsiveStyles = [];
    if (value !== undefined)
      reflectionMergePartial<SadsElementStyles>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SadsElementStyles
  ): SadsElementStyles {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional sads.v1.SadsStylingSet base_styles */ 1:
          message.baseStyles = SadsStylingSet.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.baseStyles
          );
          break;
        case /* repeated sads.v1.SadsResponsiveStyle responsive_styles */ 2:
          message.responsiveStyles.push(
            SadsResponsiveStyle.internalBinaryRead(
              reader,
              reader.uint32(),
              options
            )
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: SadsElementStyles,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* optional sads.v1.SadsStylingSet base_styles = 1; */
    if (message.baseStyles)
      SadsStylingSet.internalBinaryWrite(
        message.baseStyles,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join();
    /* repeated sads.v1.SadsResponsiveStyle responsive_styles = 2; */
    for (let i = 0; i < message.responsiveStyles.length; i++)
      SadsResponsiveStyle.internalBinaryWrite(
        message.responsiveStyles[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message sads.v1.SadsElementStyles
 */
export const SadsElementStyles = new SadsElementStyles$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SadsProcessingContext$Type extends MessageType<SadsProcessingContext> {
  constructor() {
    super("sads.v1.SadsProcessingContext", [
      { no: 1, name: "is_dark_mode", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
    ]);
  }
  create(value?: PartialMessage<SadsProcessingContext>): SadsProcessingContext {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.isDarkMode = false;
    if (value !== undefined)
      reflectionMergePartial<SadsProcessingContext>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SadsProcessingContext
  ): SadsProcessingContext {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bool is_dark_mode */ 1:
          message.isDarkMode = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: SadsProcessingContext,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* bool is_dark_mode = 1; */
    if (message.isDarkMode !== false)
      writer.tag(1, WireType.Varint).bool(message.isDarkMode);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message sads.v1.SadsProcessingContext
 */
export const SadsProcessingContext = new SadsProcessingContext$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResolveSadsStylesRequest$Type extends MessageType<ResolveSadsStylesRequest> {
  constructor() {
    super("sads.v1.ResolveSadsStylesRequest", [
      {
        no: 1,
        name: "element_styles",
        kind: "message",
        T: () => SadsElementStyles,
      },
      {
        no: 2,
        name: "context",
        kind: "message",
        T: () => SadsProcessingContext,
      },
      {
        no: 3,
        name: "theme_colors_json",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 4,
        name: "theme_spacing_json",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 5,
        name: "theme_font_size_json",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 6,
        name: "theme_breakpoints_json",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<ResolveSadsStylesRequest>
  ): ResolveSadsStylesRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.themeColorsJson = "";
    message.themeSpacingJson = "";
    message.themeFontSizeJson = "";
    message.themeBreakpointsJson = "";
    if (value !== undefined)
      reflectionMergePartial<ResolveSadsStylesRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ResolveSadsStylesRequest
  ): ResolveSadsStylesRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* sads.v1.SadsElementStyles element_styles */ 1:
          message.elementStyles = SadsElementStyles.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.elementStyles
          );
          break;
        case /* sads.v1.SadsProcessingContext context */ 2:
          message.context = SadsProcessingContext.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.context
          );
          break;
        case /* string theme_colors_json */ 3:
          message.themeColorsJson = reader.string();
          break;
        case /* string theme_spacing_json */ 4:
          message.themeSpacingJson = reader.string();
          break;
        case /* string theme_font_size_json */ 5:
          message.themeFontSizeJson = reader.string();
          break;
        case /* string theme_breakpoints_json */ 6:
          message.themeBreakpointsJson = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ResolveSadsStylesRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* sads.v1.SadsElementStyles element_styles = 1; */
    if (message.elementStyles)
      SadsElementStyles.internalBinaryWrite(
        message.elementStyles,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join();
    /* sads.v1.SadsProcessingContext context = 2; */
    if (message.context)
      SadsProcessingContext.internalBinaryWrite(
        message.context,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join();
    /* string theme_colors_json = 3; */
    if (message.themeColorsJson !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.themeColorsJson);
    /* string theme_spacing_json = 4; */
    if (message.themeSpacingJson !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.themeSpacingJson);
    /* string theme_font_size_json = 5; */
    if (message.themeFontSizeJson !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.themeFontSizeJson);
    /* string theme_breakpoints_json = 6; */
    if (message.themeBreakpointsJson !== "")
      writer
        .tag(6, WireType.LengthDelimited)
        .string(message.themeBreakpointsJson);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message sads.v1.ResolveSadsStylesRequest
 */
export const ResolveSadsStylesRequest = new ResolveSadsStylesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResolveSadsStylesResponse$Type extends MessageType<ResolveSadsStylesResponse> {
  constructor() {
    super("sads.v1.ResolveSadsStylesResponse", [
      { no: 1, name: "css_rules", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(
    value?: PartialMessage<ResolveSadsStylesResponse>
  ): ResolveSadsStylesResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.cssRules = "";
    if (value !== undefined)
      reflectionMergePartial<ResolveSadsStylesResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ResolveSadsStylesResponse
  ): ResolveSadsStylesResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string css_rules */ 1:
          message.cssRules = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ResolveSadsStylesResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string css_rules = 1; */
    if (message.cssRules !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.cssRules);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message sads.v1.ResolveSadsStylesResponse
 */
export const ResolveSadsStylesResponse = new ResolveSadsStylesResponse$Type();
